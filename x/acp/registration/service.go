package registration

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/sourcenetwork/acp_core/pkg/auth"
	"github.com/sourcenetwork/acp_core/pkg/errors"
	"github.com/sourcenetwork/acp_core/pkg/services"
	coretypes "github.com/sourcenetwork/acp_core/pkg/types"
	"github.com/sourcenetwork/sourcehub/x/acp/commitment"
	"github.com/sourcenetwork/sourcehub/x/acp/types"
)

// NewRegistrationService returns an abstraction
// layer which exposes object registration operations
func NewRegistrationService(engine *services.EngineService, eventRepo *AmendmentEventRepository, commitmentService *commitment.CommitmentService) *RegistrationService {
	return &RegistrationService{
		engine:            engine,
		commitmentService: commitmentService,
		eventRepo:         eventRepo,
	}
}

// RegistrationService abstracts object registration operations
type RegistrationService struct {
	engine            *services.EngineService
	commitmentService *commitment.CommitmentService
	eventRepo         *AmendmentEventRepository
}

// UnarchiveObject flags a given object as active, effectively re-establishing the owner relationship.
// Only the previous owner can unarchive an object.
// This operation is idempotent.
//
// If no change to the state was made, returns a nil ObjectRegistrationEvent.
// If an error happened, returns nil, nil and error
func (s *RegistrationService) UnarchiveObject(ctx sdk.Context, polId string, object *coretypes.Object) (*coretypes.UnarchiveObjectResponse, error) {
	return s.engine.UnarchiveObject(ctx, &coretypes.UnarchiveObjectRequest{
		PolicyId: polId,
		Object:   object,
	})
}

// ArchiveObject flags an object as archived and
// removes relationships from it
func (s *RegistrationService) ArchiveObject(ctx sdk.Context, polId string, object *coretypes.Object) (*coretypes.ArchiveObjectResponse, error) {
	return s.engine.ArchiveObject(ctx, &coretypes.ArchiveObjectRequest{
		PolicyId: polId,
		Object:   object,
	})
}

// RegisterObject attempts to bind an object id to an actor
// If the object has been previously registered, returns an error
//
// This operation is not idempotent.
func (s *RegistrationService) RegisterObject(ctx sdk.Context, polId string, object *coretypes.Object, actor *coretypes.Actor, msgCreator string) (*coretypes.RegisterObjectResponse, error) {
	metadata, err := types.BuildACPSuppliedMetadata(ctx, actor.Id, msgCreator)
	if err != nil {
		return nil, err
	}
	return s.engine.RegisterObject(ctx, &coretypes.RegisterObjectRequest{
		PolicyId: polId,
		Object:   object,
		Metadata: metadata,
	})
}

// amendRegistration transfers the ownership of the object in record
// to actor.
// a new amendment event is created
func (s *RegistrationService) amendRegistration(ctx sdk.Context, commitment *types.RegistrationsCommitment, record *coretypes.RelationshipRecord, actor *coretypes.Actor, msgCreator string) (*coretypes.RelationshipRecord, *types.AmendmentEvent, error) {
	object := record.Relationship.Object

	registrationMetadata, err := types.ExtractRecordMetadata(record.Metadata)
	if err != nil {
		return nil, nil, err
	}

	// registration is older than commitment
	if registrationMetadata.CreationTs.BlockHeight < commitment.Metadata.CreationTs.BlockHeight {
		return nil, nil, errors.Wrap("amendment failed: current registration older than commitment", errors.ErrorType_OPERATION_FORBIDDEN,
			errors.Pair("policy", commitment.PolicyId),
			errors.Pair("resource", object.Resource),
			errors.Pair("object", object.Id),
		)
	}

	amendMetadata, err := types.BuildACPSuppliedMetadataWithTime(ctx, commitment.Metadata.CreationTs, actor.Id, msgCreator)
	if err != nil {
		return nil, nil, err
	}

	goCtx := auth.InjectPrincipal(ctx, coretypes.RootPrincipal())
	ctx = ctx.WithContext(goCtx)
	result, err := s.engine.AmendRegistration(ctx, &coretypes.AmendRegistrationRequest{
		PolicyId:      commitment.PolicyId,
		Object:        object,
		NewOwner:      actor,
		NewCreationTs: commitment.Metadata.CreationTs.ProtoTs,
		Metadata:      amendMetadata,
	})
	if err != nil {
		return nil, nil, err
	}

	eventMetadata, err := types.BuildRecordMetadata(ctx, actor.Id, msgCreator)
	if err != nil {
		return nil, nil, err
	}
	event := &types.AmendmentEvent{
		Id:            0, // doesn't matter, will get autogenerated
		PolicyId:      commitment.PolicyId,
		Object:        object,
		NewOwner:      actor,
		PreviousOwner: coretypes.NewActor(record.Metadata.Creator.Identifier),
		CommitmentId:  commitment.Id,
		HijackFlag:    false,
		Metadata:      eventMetadata,
	}
	err = s.eventRepo.create(ctx, event)
	if err != nil {
		return nil, nil, err
	}

	return result.Record, event, nil
}

// RevealRegistation attempts to register an object from a commitment opening.
// If the opening is valid, registers the object.
// Returns an AmendmentEvent if the object registration was amended
//
// In the event where the opening is valid and the object was already registered,
// if the commitment is older than the registration, run the amendment protocol
// which transfers the object's ownership to the commitment author.
func (s *RegistrationService) RevealRegistration(ctx sdk.Context, commitmentId uint64, proof *types.RegistrationProof, actor *coretypes.Actor, msgSigner string) (*coretypes.RelationshipRecord, *types.AmendmentEvent, error) {
	commitment, ok, err := s.commitmentService.ValidateOpening(ctx, commitmentId, proof, actor)
	if err != nil {
		return nil, nil, err
	}
	if !ok {
		return nil, nil, errors.Wrap("invalid registration opening", errors.ErrorType_UNAUTHORIZED)
	}

	registrationRecord, err := s.engine.GetObjectRegistration(ctx, &coretypes.GetObjectRegistrationRequest{
		PolicyId: commitment.PolicyId,
		Object:   proof.Object,
	})
	if err != nil {
		return nil, nil, err
	}

	if !registrationRecord.IsRegistered {
		// Use the commitment creation ts to prevent a secondary amendment
		metadata, err := types.BuildACPSuppliedMetadataWithTime(ctx, commitment.Metadata.CreationTs, actor.Id, msgSigner)
		if err != nil {
			return nil, nil, err
		}

		result, err := s.engine.RevealRegistration(ctx, &coretypes.RevealRegistrationRequest{
			PolicyId:   commitment.PolicyId,
			Object:     proof.Object,
			Metadata:   metadata,
			CreationTs: commitment.Metadata.CreationTs.ProtoTs,
		})
		if err != nil {
			return nil, nil, err
		}

		return result.Record, nil, nil
	}

	return s.amendRegistration(ctx, commitment, registrationRecord.Record, actor, msgSigner)
}

// FlagHijackEvent sets the hijack flag of an amendment event to true
func (s *RegistrationService) FlagHijackEvent(ctx sdk.Context, eventId uint64, actor *coretypes.Actor) (*types.AmendmentEvent, error) {
	opt, err := s.eventRepo.GetById(ctx, eventId)
	if err != nil {
		return nil, err
	}
	if opt.Empty() {
		return nil, errors.Wrap("event not found", errors.ErrorType_NOT_FOUND, errors.Pair("event", eventId))
	}
	event := opt.GetValue()

	if event.Metadata.OwnerDid != actor.Id {
		return nil, errors.Wrap("event actor missmatch: actor must be event subject",
			errors.ErrorType_UNAUTHORIZED,
			errors.Pair("event", eventId),
			errors.Pair("expected_actor", actor.Id),
		)
	}

	event.HijackFlag = true
	err = s.eventRepo.update(ctx, event)
	if err != nil {
		return nil, err
	}

	return event, nil
}
