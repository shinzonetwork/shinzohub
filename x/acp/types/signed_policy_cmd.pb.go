// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sourcehub/acp/signed_policy_cmd.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/cosmos/gogoproto/types"
	_ "github.com/sourcenetwork/acp_core/pkg/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SignedPolicyCmd represents a Command issued by an Actor in the context of a Policy
// The command represents an instruction to be executed
// The message type contains a signature which is used to authenticate the Command's Actor
type SignedPolicyCmd struct {
	// payload contains the command context
	Payload *SignedPolicyCmdPayload `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// signature is a signature of the payload.
	// The signature is generated using the VerificationMethod / Authorization fields
	// specificied by the DID document of the Actor.
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *SignedPolicyCmd) Reset()         { *m = SignedPolicyCmd{} }
func (m *SignedPolicyCmd) String() string { return proto.CompactTextString(m) }
func (*SignedPolicyCmd) ProtoMessage()    {}
func (*SignedPolicyCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_8eb2671203f09829, []int{0}
}
func (m *SignedPolicyCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedPolicyCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedPolicyCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedPolicyCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedPolicyCmd.Merge(m, src)
}
func (m *SignedPolicyCmd) XXX_Size() int {
	return m.Size()
}
func (m *SignedPolicyCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedPolicyCmd.DiscardUnknown(m)
}

var xxx_messageInfo_SignedPolicyCmd proto.InternalMessageInfo

func (m *SignedPolicyCmd) GetPayload() *SignedPolicyCmdPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *SignedPolicyCmd) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SignedPolicyCmdPayload represents the payload containing the context of the issued command
type SignedPolicyCmdPayload struct {
	// actor is a did string representing the actor which issued the command
	Actor string `protobuf:"bytes,1,opt,name=actor,proto3" json:"actor,omitempty"`
	// issued_height is the SourceHub block height of when the Payload was created
	IssuedHeight uint64 `protobuf:"varint,2,opt,name=issued_height,json=issuedHeight,proto3" json:"issued_height,omitempty"`
	// issued_at contains a client generated timestamp for the creation of the command.
	// This is used only as metadata and isn't trusted
	IssuedAt *types.Timestamp `protobuf:"bytes,3,opt,name=issued_at,json=issuedAt,proto3" json:"issued_at,omitempty"`
	// expiration_delta specifies the maximum number of blocks from the issued height during which the Command Payload will be accepted.
	// This field is mandatory and is used to prevent replay attacks
	ExpirationDelta uint64 `protobuf:"varint,4,opt,name=expiration_delta,json=expirationDelta,proto3" json:"expiration_delta,omitempty"`
	// policy_id is the ID of the policy under which the Command will be executed
	PolicyId string     `protobuf:"bytes,5,opt,name=policy_id,json=policyId,proto3" json:"policy_id,omitempty"`
	Cmd      *PolicyCmd `protobuf:"bytes,6,opt,name=cmd,proto3" json:"cmd,omitempty"`
}

func (m *SignedPolicyCmdPayload) Reset()         { *m = SignedPolicyCmdPayload{} }
func (m *SignedPolicyCmdPayload) String() string { return proto.CompactTextString(m) }
func (*SignedPolicyCmdPayload) ProtoMessage()    {}
func (*SignedPolicyCmdPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_8eb2671203f09829, []int{1}
}
func (m *SignedPolicyCmdPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedPolicyCmdPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedPolicyCmdPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedPolicyCmdPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedPolicyCmdPayload.Merge(m, src)
}
func (m *SignedPolicyCmdPayload) XXX_Size() int {
	return m.Size()
}
func (m *SignedPolicyCmdPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedPolicyCmdPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SignedPolicyCmdPayload proto.InternalMessageInfo

func (m *SignedPolicyCmdPayload) GetActor() string {
	if m != nil {
		return m.Actor
	}
	return ""
}

func (m *SignedPolicyCmdPayload) GetIssuedHeight() uint64 {
	if m != nil {
		return m.IssuedHeight
	}
	return 0
}

func (m *SignedPolicyCmdPayload) GetIssuedAt() *types.Timestamp {
	if m != nil {
		return m.IssuedAt
	}
	return nil
}

func (m *SignedPolicyCmdPayload) GetExpirationDelta() uint64 {
	if m != nil {
		return m.ExpirationDelta
	}
	return 0
}

func (m *SignedPolicyCmdPayload) GetPolicyId() string {
	if m != nil {
		return m.PolicyId
	}
	return ""
}

func (m *SignedPolicyCmdPayload) GetCmd() *PolicyCmd {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func init() {
	proto.RegisterType((*SignedPolicyCmd)(nil), "sourcehub.acp.SignedPolicyCmd")
	proto.RegisterType((*SignedPolicyCmdPayload)(nil), "sourcehub.acp.SignedPolicyCmdPayload")
}

func init() {
	proto.RegisterFile("sourcehub/acp/signed_policy_cmd.proto", fileDescriptor_8eb2671203f09829)
}

var fileDescriptor_8eb2671203f09829 = []byte{
	// 412 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0xcf, 0x6e, 0xd4, 0x30,
	0x10, 0xc6, 0x37, 0xfd, 0x47, 0xd7, 0xb4, 0x2a, 0xb2, 0x10, 0x8a, 0x02, 0x0a, 0xab, 0xa2, 0x4a,
	0x2d, 0x07, 0x47, 0x82, 0x03, 0x47, 0xc4, 0x9f, 0x43, 0xb9, 0x55, 0x81, 0x13, 0x97, 0xc8, 0x6b,
	0x9b, 0xc4, 0x22, 0x8e, 0x2d, 0x7b, 0x22, 0xba, 0x37, 0x1e, 0x81, 0xc7, 0xe2, 0xd8, 0x23, 0x47,
	0xb4, 0xfb, 0x22, 0x55, 0xec, 0xa4, 0xab, 0x44, 0x7b, 0xcc, 0x37, 0x3f, 0xcf, 0xcc, 0x37, 0x5f,
	0xd0, 0x85, 0xd3, 0xad, 0x65, 0xa2, 0x6a, 0x97, 0x19, 0x65, 0x26, 0x73, 0xb2, 0x6c, 0x04, 0x2f,
	0x8c, 0xae, 0x25, 0x5b, 0x15, 0x4c, 0x71, 0x62, 0xac, 0x06, 0x8d, 0x4f, 0x1f, 0x30, 0x42, 0x99,
	0x49, 0x5e, 0x96, 0x5a, 0x97, 0xb5, 0xc8, 0x7c, 0x71, 0xd9, 0xfe, 0xc8, 0x40, 0x2a, 0xe1, 0x80,
	0x2a, 0x13, 0xf8, 0xe4, 0x2a, 0xf0, 0x8d, 0x80, 0x5f, 0xda, 0xfe, 0xec, 0x5a, 0x17, 0x4c, 0x5b,
	0x91, 0x59, 0x51, 0x53, 0x90, 0xba, 0x71, 0x95, 0x1c, 0xd0, 0x74, 0xbc, 0x01, 0xd3, 0x4a, 0x49,
	0x50, 0xa2, 0x81, 0xbe, 0xbe, 0x18, 0xd7, 0xad, 0x28, 0xa5, 0x03, 0xeb, 0xbb, 0xf4, 0x44, 0x32,
	0x25, 0x98, 0xb6, 0x7c, 0x77, 0xf7, 0xa9, 0xb1, 0x73, 0x83, 0xce, 0xbe, 0x7a, 0xcf, 0x37, 0xbe,
	0xf2, 0x49, 0x71, 0xfc, 0x1e, 0x3d, 0x32, 0x74, 0x55, 0x6b, 0xca, 0xe3, 0x68, 0x11, 0x5d, 0x3e,
	0x7e, 0x73, 0x41, 0x46, 0xee, 0xc9, 0xe4, 0xc1, 0x4d, 0x80, 0xf3, 0xe1, 0x15, 0x7e, 0x81, 0xe6,
	0xdd, 0x1d, 0x29, 0xb4, 0x56, 0xc4, 0x7b, 0x8b, 0xe8, 0xf2, 0x24, 0xdf, 0x0a, 0xe7, 0xbf, 0xf7,
	0xd0, 0xb3, 0xdd, 0x1d, 0xf0, 0x53, 0x74, 0x48, 0x19, 0x68, 0xeb, 0xe7, 0xce, 0xf3, 0xf0, 0x81,
	0x5f, 0xa1, 0x53, 0xe9, 0x5c, 0x2b, 0x78, 0x51, 0x09, 0x59, 0x56, 0xe0, 0x5b, 0x1e, 0xe4, 0x27,
	0x41, 0xbc, 0xf6, 0x1a, 0x7e, 0x87, 0xe6, 0x3d, 0x44, 0x21, 0xde, 0xf7, 0x6b, 0x27, 0x24, 0xa4,
	0x44, 0x86, 0x94, 0xc8, 0xb7, 0x21, 0xa5, 0xfc, 0x38, 0xc0, 0x1f, 0x00, 0x5f, 0xa1, 0x27, 0xe2,
	0xd6, 0xc8, 0x70, 0xd0, 0x82, 0x8b, 0x1a, 0x68, 0x7c, 0xe0, 0x07, 0x9c, 0x6d, 0xf5, 0xcf, 0x9d,
	0x8c, 0x9f, 0xa3, 0x79, 0x7f, 0x3f, 0xc9, 0xe3, 0x43, 0xbf, 0xe2, 0x71, 0x10, 0xbe, 0x70, 0xfc,
	0x1a, 0xed, 0x33, 0xc5, 0xe3, 0x23, 0x3f, 0x3a, 0x9e, 0x5c, 0xec, 0xc1, 0x69, 0xde, 0x41, 0x1f,
	0xaf, 0xff, 0xae, 0xd3, 0xe8, 0x6e, 0x9d, 0x46, 0xff, 0xd7, 0x69, 0xf4, 0x67, 0x93, 0xce, 0xee,
	0x36, 0xe9, 0xec, 0xdf, 0x26, 0x9d, 0x7d, 0x27, 0xa5, 0x84, 0xee, 0x11, 0xd3, 0x2a, 0x1b, 0xff,
	0x42, 0xdb, 0x1c, 0x6f, 0x7d, 0x92, 0xb0, 0x32, 0xc2, 0x2d, 0x8f, 0xbc, 0xb7, 0xb7, 0xf7, 0x01,
	0x00, 0x00, 0xff, 0xff, 0x52, 0x66, 0x4e, 0x3a, 0xc7, 0x02, 0x00, 0x00,
}

func (m *SignedPolicyCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedPolicyCmd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedPolicyCmd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintSignedPolicyCmd(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSignedPolicyCmd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignedPolicyCmdPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedPolicyCmdPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedPolicyCmdPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Cmd != nil {
		{
			size, err := m.Cmd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSignedPolicyCmd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.PolicyId) > 0 {
		i -= len(m.PolicyId)
		copy(dAtA[i:], m.PolicyId)
		i = encodeVarintSignedPolicyCmd(dAtA, i, uint64(len(m.PolicyId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ExpirationDelta != 0 {
		i = encodeVarintSignedPolicyCmd(dAtA, i, uint64(m.ExpirationDelta))
		i--
		dAtA[i] = 0x20
	}
	if m.IssuedAt != nil {
		{
			size, err := m.IssuedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSignedPolicyCmd(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IssuedHeight != 0 {
		i = encodeVarintSignedPolicyCmd(dAtA, i, uint64(m.IssuedHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Actor) > 0 {
		i -= len(m.Actor)
		copy(dAtA[i:], m.Actor)
		i = encodeVarintSignedPolicyCmd(dAtA, i, uint64(len(m.Actor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSignedPolicyCmd(dAtA []byte, offset int, v uint64) int {
	offset -= sovSignedPolicyCmd(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SignedPolicyCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovSignedPolicyCmd(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovSignedPolicyCmd(uint64(l))
	}
	return n
}

func (m *SignedPolicyCmdPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Actor)
	if l > 0 {
		n += 1 + l + sovSignedPolicyCmd(uint64(l))
	}
	if m.IssuedHeight != 0 {
		n += 1 + sovSignedPolicyCmd(uint64(m.IssuedHeight))
	}
	if m.IssuedAt != nil {
		l = m.IssuedAt.Size()
		n += 1 + l + sovSignedPolicyCmd(uint64(l))
	}
	if m.ExpirationDelta != 0 {
		n += 1 + sovSignedPolicyCmd(uint64(m.ExpirationDelta))
	}
	l = len(m.PolicyId)
	if l > 0 {
		n += 1 + l + sovSignedPolicyCmd(uint64(l))
	}
	if m.Cmd != nil {
		l = m.Cmd.Size()
		n += 1 + l + sovSignedPolicyCmd(uint64(l))
	}
	return n
}

func sovSignedPolicyCmd(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSignedPolicyCmd(x uint64) (n int) {
	return sovSignedPolicyCmd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SignedPolicyCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSignedPolicyCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedPolicyCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedPolicyCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignedPolicyCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &SignedPolicyCmdPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignedPolicyCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSignedPolicyCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedPolicyCmdPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSignedPolicyCmd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedPolicyCmdPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedPolicyCmdPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignedPolicyCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuedHeight", wireType)
			}
			m.IssuedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignedPolicyCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IssuedHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignedPolicyCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IssuedAt == nil {
				m.IssuedAt = &types.Timestamp{}
			}
			if err := m.IssuedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationDelta", wireType)
			}
			m.ExpirationDelta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignedPolicyCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationDelta |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolicyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignedPolicyCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PolicyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSignedPolicyCmd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cmd == nil {
				m.Cmd = &PolicyCmd{}
			}
			if err := m.Cmd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSignedPolicyCmd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSignedPolicyCmd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSignedPolicyCmd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSignedPolicyCmd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSignedPolicyCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSignedPolicyCmd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSignedPolicyCmd
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSignedPolicyCmd
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSignedPolicyCmd
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSignedPolicyCmd        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSignedPolicyCmd          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSignedPolicyCmd = fmt.Errorf("proto: unexpected end of group")
)
